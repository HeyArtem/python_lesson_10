# 10.1 Polymorfism. Скопирую игру в кости из прошлого урока.


# Разобраться самому, препод сказал сами посмотрите и я забыл как работает механика игры
import random
from dice_game import Dice
''''
Полиморфизм в объектно-ориентированном программировании– это возможность обработки разных типов данных, 
т. е. принадлежащих к разным классам, с помощью "одно и той же" функции, или метода. 
На самом деле одинаковым является только имя метода, его исходный код зависит от класса. 
Кроме того, результаты работы одноименных методов могут существенно различаться. 
Поэтому в данном контексте под полиморфизмом понимается множество форм одного и того же слова – имени метода.

Например, два разных класса содержат метод total, однако инструкции каждого предусматривают совершенно разные операции.


Сделаем несколько полиморфных от класса Dice
Будем создавать классы с разным типом игры 
(второй тип я разместил на странице 10.1_polymorfism_2)

Поменяем функцию - функцию бросания type_1
'''
print('    Пример полиморфизма 1 - Dice_type_1(Dice)\n' +
      'В этом примере, я изменил метод throw_dices(self)\n '
      'и теперь для того, что бы "Игрок-1" одержал победу, нужно что бы сумма даайсов совпала с сумой выпавшей у игрока "Компьютер" \n')


class Dice_type_1(Dice):
    def throw_dices(self):
        '''
        Это метод из родительского класса, но мы меняем его.
        А конкретно, теперь при сравнеии выпавших показаний дайсов игроков  "Компьютер" и "Игрок-1"
        Будет выводиться True, если их сумма равна (в родительском варианте должны были совпасть показания)
        '''
        dice_1 = random.randint(1, 6) # бросаем кости
        dice_2 = random.randint(1, 6) # бросаем кости 2
        self.current_throw+=1
        print("Счетчик количества бросков (self.current_throw): ", self.current_throw)
        print("Комбинация выпавшая у 'Игрок-1' dice 1 и 2: ", dice_1, dice_2 )

        if self.current_throw > self.throw_num: # если количество бросков превысило запланированное
            raise Exception("Вы превысили количество попыток! ")

        if {dice_1 + dice_2} == {self._hidden_num_1 + self._hidden_num_2}: # Здесь мы сделали изменения
            return True
        else:
            return False

if __name__ == '__main__':
    #game = Dice(1)
    game_type_1 = Dice_type_1(20) # Не понимаю, что я меня числом в скобках
    game_type_1.set_hidden_numbers()
    print('Игрок "Компьютер" (_hidden_num_1 и_hidden_num_2) : ', game_type_1._hidden_num_1, game_type_1._hidden_num_2)
    for i in range(3):
        '''
        число в скобках = количество бросков, которое сделает 'Игрок-1', 
        что бы угадать комбинацию игрока "Компьютер"  
        '''
        try:
            print(game_type_1.throw_dices())
        except:
            print("Игра закончена")



    # game_type_2 = Dice_type_2(5)


    # ''' Выведим типы методов: game_type_1  game_type_2 '''
    # print(type(game_type_1))
    # # print(type(game_type_2))
    # print(type(game))






    # game = Dice_type_1(3)  # Я так и не понял, как это запустить!!!

    #print(game)
    #game.throw_dices()
    #print(game.dice_1, game.dice_2)
    # for i in range(4):  # зачем Dice=20 и range=100?
    #     try:
    #         print(game.throw_dices())
    #     except:
    #         print("Игра закончена")

    #print(type(game)) # посмотрим типы созданных обьектов


